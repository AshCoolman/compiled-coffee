// Generated by CoffeeScript 1.3.3
(function() {
  "TODO:\n- use TypeScript.api for watching and skip the fs.";

  var Builder, CoffeeScriptError, EventEmitter, TypeScriptError, async, coffee_script, cs_helpers, fs, go, mergeDefinition, path, spawn, suspend, ts_yield, writestreamp,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  suspend = require('suspend');

  go = suspend.resume;

  spawn = require('child_process').spawn;

  async = require('async');

  ts_yield = require('../../node_modules/typescript-yield/build/functions.js');

  fs = require('fs');

  writestreamp = require('writestreamp');

  mergeDefinition = require('../dts-merger/merger').merge;

  coffee_script = require("../../node_modules/coffee-script-to-" + "typescript/lib/coffee-script");

  cs_helpers = require("../../node_modules/coffee-script-to-" + "typescript/lib/helpers");

  path = require('path');

  EventEmitter = require('events').EventEmitter;

  require('sugar');

  Builder = (function(_super) {

    __extends(Builder, _super);

    Builder.prototype.clock = 0;

    Builder.prototype.build_dirs_created = false;

    Builder.prototype.source_dir = null;

    Builder.prototype.output_dir = null;

    Builder.prototype.sep = path.sep;

    function Builder(files, source_dir, output_dir, pack, _yield) {
      this.files = files;
      this.pack = pack != null ? pack : false;
      this["yield"] = _yield != null ? _yield : false;
      Builder.__super__.constructor.apply(this, arguments);
      this.output_dir = path.resolve(output_dir);
      this.source_dir = path.resolve(source_dir);
      this.coffee_suffix = /\.coffee$/;
    }

    Builder.prototype.prepareDirs = suspend.async(function*() {
      var dirs,
        _this = this;
      if (this.build_dirs_created) {
        return;
      }
      dirs = [this.output_dir];
      if (this.pack) {
        dirs.push(this.output_dir + this.sep + 'dist');
      }
      yield async.eachSeries(dirs, suspend.async(function*(dir) {
        var exists;
        exists = yield fs.exists(dir, suspend.resumeRaw());
        if (!exists[0]) {
          return yield fs.mkdir(dir, go());
        }
      }), go());
      return this.build_dirs_created = true;
    });

    Builder.prototype.build = suspend.async(function*() {
      var error, module_name, sources, tick,
        _this = this;
      tick = ++this.clock;
      error = false;
      yield this.prepareDirs(go());
      if (this.clock !== tick) {
        return this.emit('aborted');
      }
      sources = yield async.map(this.files, this.processSource.bind(this, tick), go());
      if (this.clock !== tick) {
        return this.emit('aborted');
      }
      this.proc = spawn("" + __dirname + "/../../node_modules/typescript/bin/tsc", ["" + __dirname + "/../../d.ts/ecma.d.ts", "--module", "commonjs", "--declaration", "--sourcemap", "--noLib"].include(this.tsFiles()), {
        cwd: "" + this.output_dir + "/"
      });
      this.proc.stderr.setEncoding('utf8');
      this.proc.stderr.on('data', function(err) {
        var remove;
        remove = "" + _this.output_dir + _this.sep;
        while (~err.indexOf(remove)) {
          err = err.replace(remove, '');
        }
        return process.stdout.write(err);
      });
      try {
        yield this.proc.on('close', go());
      } catch (e) {
        throw new TypeScriptError;
      }
      if (this.clock !== tick) {
        return this.emit('aborted');
      }
      yield async.map(this.files, this.processBuiltSource.bind(this, tick), go());
      if (this.clock !== tick) {
        return this.emit('aborted');
      }
      if (this.pack) {
        module_name = (this.pack.split(':')).slice(-1);
        this.proc = spawn("" + __dirname + "/../../node_modules/browserify/bin/cmd.js", ["-r", "./" + this.pack, "--no-builtins", "--insert-globals", "-o", "" + this.output_dir + "-pkg/" + module_name + ".js"], {
          cwd: "" + this.output_dir + "/"
        });
        this.proc.stderr.setEncoding('utf8');
        this.proc.stderr.on('data', function(err) {
          var remove;
          remove = "" + _this.output_dir + _this.sep;
          while (~err.indexOf(remove)) {
            err = err.replace(remove, '');
          }
          return process.stdout.write(err);
        });
        yield this.proc.on('close', go());
        if (this.clock !== tick) {
          return this.emit('aborted');
        }
      }
      return this.proc = null;
    });

    Builder.prototype.tsFiles = function() {
      var file, files;
      return files = (function() {
        var _i, _len, _ref, _results;
        _ref = this.files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          _results.push(file.replace(this.coffee_suffix, '.ts'));
        }
        return _results;
      }).call(this);
    };

    Builder.prototype.dtsFiles = function() {
      var file, files;
      return files = (function() {
        var _i, _len, _ref, _results;
        _ref = this.files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          _results.push(file.replace(this.coffee_suffix, '.d.ts'));
        }
        return _results;
      }).call(this);
    };

    Builder.prototype.processSource = suspend.async(function*(tick, file) {
      var source;
      source = yield this.readSourceFile(file, go());
      if (this.clock !== tick) {
        return this.emit('aborted');
      }
      source = this.processCoffee(file, source);
      source = yield this.mergeDefinition(file, source, go());
      yield this.writeTsFile(file, source, go());
      return {
        file: file.replace(/\.coffee$/, '.ts'),
        source: source
      };
    });

    Builder.prototype.processCoffee = function(file, source) {
      var js, v3SourceMap, _ref;
      try {
        cs_helpers.setTranslatingFile(file, source);
        _ref = coffee_script.compile(source, {
          sourceMap: true
        }), js = _ref.js, v3SourceMap = _ref.v3SourceMap;
        return js;
      } catch (e) {
        throw new CoffeeScriptError;
      }
    };

    Builder.prototype.readSourceFile = suspend.async(function*(file) {
      return yield fs.readFile([this.source_dir, file].join(this.sep), {
        encoding: 'utf8'
      }, go());
    });

    Builder.prototype.processBuiltSource = suspend.async(function*(tick, file) {
      var js_file, source;
      js_file = file.replace(this.coffee_suffix, '.js');
      source = yield fs.readFile(this.output_dir + this.sep + js_file, {
        encoding: 'utf8'
      }, go());
      if (this.clock !== tick) {
        return this.emit('aborted');
      }
      if (this["yield"]) {
        source = this.transpileYield(source);
      }
      return yield this.writeJsFile(file, source, go());
    });

    Builder.prototype.transpileYield = function(source) {
      return ts_yield.markGenerators(ts_yield.unwrapYield(source));
    };

    Builder.prototype.writeTsFile = suspend.async(function*(file, source) {
      var destination, ts_file;
      ts_file = file.replace(this.coffee_suffix, '.ts');
      destination = writestreamp("" + this.output_dir + "/" + ts_file);
      return yield destination.end(source, 'utf8', go());
    });

    Builder.prototype.writeJsFile = suspend.async(function*(file, source) {
      var destination, js_file;
      js_file = file.replace(this.coffee_suffix, '.js');
      destination = writestreamp("" + this.output_dir + "/" + js_file);
      return yield destination.end(source, 'utf8', go());
    });

    Builder.prototype.mergeDefinition = suspend.async(function*(file, source) {
      var definition, dts_file, exists;
      dts_file = file.replace(this.coffee_suffix, '.d.ts');
      exists = yield fs.exists(this.source_dir + this.sep + dts_file, suspend.resumeRaw());
      if (exists[0]) {
        definition = yield fs.readFile(this.source_dir + this.sep + dts_file, {
          encoding: 'utf8'
        }, go());
        return mergeDefinition(source, definition);
      } else {
        return source;
      }
    });

    Builder.prototype.close = function() {
      var _ref;
      return (_ref = this.proc) != null ? _ref.kill() : void 0;
    };

    Builder.prototype.clean = function() {
      throw new Error('not implemented');
    };

    Builder.prototype.reload = suspend.async(function*(refreshed) {
      var _ref;
      if (refreshed) {
        console.log('-'.repeat(20));
      }
      if ((_ref = this.proc) != null) {
        _ref.kill();
      }
      try {
        yield this.build(go());
      } catch (e) {
        if (!(e instanceof TypeScriptError) && !(e instanceof CoffeeScriptError)) {
          throw e;
        }
      }
      return console.log("Compilation completed");
    });

    Builder.prototype.watch = suspend.async(function*() {
      var exists, file, node, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      _ref = this.files;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        node = this.source_dir + this.sep + file;
        fs.watchFile(node, {
          persistent: true,
          interval: 500
        }, function() {
          return _this.reload(true, function() {});
        });
      }
      _ref1 = this.dtsFiles();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        file = _ref1[_j];
        node = this.source_dir + this.sep + file;
        exists = yield fs.exists(node, suspend.resumeRaw());
        if (!exists[0]) {
          continue;
        }
        fs.watchFile(node, {
          persistent: true,
          interval: 500
        }, function() {
          return _this.reload(true, function() {});
        });
      }
      return yield this.reload(false, go());
    });

    return Builder;

  })(EventEmitter);

  module.exports = Builder;

  TypeScriptError = (function(_super) {

    __extends(TypeScriptError, _super);

    function TypeScriptError() {
      TypeScriptError.__super__.constructor.call(this, 'TypeScript compilation error');
    }

    return TypeScriptError;

  })(Error);

  CoffeeScriptError = (function(_super) {

    __extends(CoffeeScriptError, _super);

    function CoffeeScriptError() {
      CoffeeScriptError.__super__.constructor.call(this, 'CoffeeScript compilation error');
    }

    return CoffeeScriptError;

  })(Error);

}).call(this);
